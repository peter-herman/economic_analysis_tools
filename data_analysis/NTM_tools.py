import pandas as pd
import math as math
from typing import Union

def across_country_ave(results_dict:dict,
                       sigma:Union[float,object],
                       fixed_effect_prefix:str = 'imp_fe',
                       country_list:list = None,
                       year_by_year = False):
    '''
    A function to calculate ad valorem equivalents according to the methodology described in Fontagne et al. (2011).
    The computed AVEs a relative to the least restrictive/most competitive country based on the estimated fixed effects
    :param results_dict: (dict) a dictionary of sm.glm results, as would be returned from estimate_glm()
    :param sigma: (numeric or DataFrame) a substitution elasticity to be used for the calculation of AVEs. If a
        Dataframe, it should be formatted with two columns corresponding to [sector, sigma] in that order.
    :param fixed_effect_prefix: (str) the prefix of the indexes corresponding to the desired fixed effects
    :param year_by_year: (bool) Changes treatment of country-year fixed effects,  If True, separates fixed effects by
        year so that AVEs a generated by comparing FEs within the same year. To do so, fixed effects must be
        country-year such that the names have the years as the last 4 characters (e.g. imp_fe_USA_2015).
        Default is False, in which case all years are pooled together within each calculation using a common benchmark.
    :return: (DataFrame) a Pandas dataframe consisting of the estimated AVEs for each country and sector.
    '''
    # Prep elasticity input if DataFrame
    if isinstance(sigma, pd.DataFrame):
        elast_dict = {}
        for row in sigma.index:
            elast_dict[str(sigma.iloc[row, 0])] = sigma.iloc[row, 1]
        sigma = elast_dict

    list_of_series = []
    for product in results_dict.keys():
        # Perform calculation for all years (if applicable) pooled together
        coeffs = pd.DataFrame(results_dict[product].params)
        #coeffs['variable'] = coeffs.index
        coeffs.rename(columns = {0:str(product)}, inplace = True)
        fe_list = [row for row in results_dict[product].params.keys() if row.startswith(fixed_effect_prefix)]

        # Collect a subset of countries
        if country_list is not None:
            temp_list = []
            for country in country_list:
                [temp_list.append(fe) for fe in fe_list if country in fe]
            fe_list = temp_list

        mask = coeffs.index.isin(fe_list)
        coeffs = coeffs.loc[mask, :]

        if year_by_year:
            coeffs.reset_index(inplace = True)
            coeffs['year'] = coeffs['index'].str[-4:]
            coeffs['index'] = coeffs['index'].str[:-4]
            coeffs.index = coeffs['index']
            coeffs.drop(['index'], axis = 1,inplace = True)
            year_list = coeffs['year'].unique().tolist()
            for year in year_list:
                new_col_name = (product + '_' + year)
                year_subset = coeffs.loc[coeffs['year'] == year,[product]]
                year_subset.rename(columns = {product:new_col_name}, inplace=True)
                list_of_series.append(year_subset)

                # expand sigma dictionary to new product-years
                if isinstance(sigma, dict):
                    sigma[new_col_name] = sigma[product]

        else:
            list_of_series.append(coeffs)

    all_imp_fe = pd.concat(list_of_series, join = 'outer', axis = 1)


    for col in all_imp_fe.columns:
        if isinstance(sigma, dict):
            sigma_value = sigma[col]
        elif isinstance(sigma, (int, float)):
            sigma_value = sigma
        else:
            raise TypeError('sigma is not a valid type')

        ave = lambda x: math.exp(x / (1 - sigma_value)) - 1
        max_fe = all_imp_fe[col].max()
        all_imp_fe[col] = all_imp_fe[col] - max_fe
        all_imp_fe[col] = all_imp_fe[col].apply(ave)
        all_imp_fe.loc[:,str('sigma_'+col)] = sigma_value
    return all_imp_fe

def prep_ave_data_for_ols(ave_data,
                          fe_prefix:str):
    '''
    A function that converts the output from across_country_ave() to a single series that can be used for an OLS
    regression.
    :param ave_data: (DataFrame) A dataframe of AVEs from across_country_ave(). Rows correspond to countries,
    columns to sectors.
    :param fe_prefix: (str) the prefix of the indexes corresponding to the country-AVEs
    :return: (DataFrame) A dataframe in which there is a single column of AVEs, and ID columns of countries associated
    with the AVEs, and the sectors to which they belong.
    '''
    products = list(ave_data.columns.values)
    products.remove('sigma')
    product_frame_list = []
    for code in products:
        product_frame = ave_data[[code]].copy()
        product_frame.rename(columns={code: fe_prefix}, inplace=True)
        product_frame['sector'] = code
        product_frame['country'] = product_frame.index.str.slice(-3)
        product_frame_list.append(product_frame)
    fixed_effect_df = pd.concat(product_frame_list, axis=0)
    return fixed_effect_df


