import pandas as pd
import math as math
from typing import Union
from warnings import warn
def across_country_ave(results_dict:dict,
                       sigma:Union[float,object],
                       fixed_effect_prefix:str = 'imp_fe',
                       country_list:list = None,
                       year_by_year = False,
                       format:str = 'long'):
    '''
    A function to calculate ad valorem equivalents according to the methodology described in Fontagne et al. (2011).
    The computed AVEs a relative to the least restrictive/most competitive country based on the estimated fixed effects
    :param results_dict: (dict) a dictionary of sm.glm results, as would be returned from estimate_glm(). Each
        dictionary is treated as a different 'sector'.
    :param sigma: (numeric or DataFrame) a substitution elasticity to be used for the calculation of AVEs. If a
        Dataframe, it should be formatted with two columns corresponding to [sector, sigma] in that order.
    :param fixed_effect_prefix: (str) the prefix of the indexes corresponding to the desired fixed effects
    :param year_by_year: (bool) Changes treatment of country-year fixed effects,  If True, separates fixed effects by
        year so that AVEs a generated by comparing FEs within the same year. To do so, fixed effects must be
        country-year such that the names have the years as the last 4 characters (e.g. imp_fe_USA_2015).
        Default is False, in which case all years are pooled together within each calculation using a common benchmark.
    :param format: (str) Accepts 'long' (default) or 'wide'. If long, each row is identified by a country, sector, and
        year if applicable. If wide, Rows are identified by country only and each year and sector appears in different
        columns.
    :return: (DataFrame) a Pandas dataframe consisting of the estimated AVEs for each country and sector.
    '''
    # Prep elasticity input if DataFrame
    if isinstance(sigma, pd.DataFrame):
        elast_dict = {}
        for row in sigma.index:
            elast_dict[str(sigma.iloc[row, 0])] = sigma.iloc[row, 1]
        sigma = elast_dict

    list_of_series = []
    for product in results_dict.keys():
        # Perform calculation for all years (if applicable) pooled together

        # Collect parameter values
        coeffs = pd.DataFrame(results_dict[product].params)
        coeffs.rename(columns = {0:"fe_{}".format(str(product))}, inplace = True)

        pvals = pd.DataFrame(results_dict[product].pvalues)
        pvals.rename(columns = {0:"pval_{}".format(str(product))}, inplace = True)

        coeffs = pd.concat([coeffs, pvals], axis = 1)

        fe_list = [row for row in results_dict[product].params.keys() if row.startswith(fixed_effect_prefix)]

        # Collect a subset of countries
        if country_list is not None:
            temp_list = []
            for country in country_list:
                [temp_list.append(fe) for fe in fe_list if country in fe]
            fe_list = temp_list

        mask = coeffs.index.isin(fe_list)
        coeffs = coeffs.loc[mask, :].copy()

        if year_by_year:
            # Split index of fixed effect names into a year and ID component
            coeffs.reset_index(inplace = True)
            coeffs['year'] = coeffs['index'].str[-4:]
            coeffs['index'] = coeffs['index'].str[:-4]
            coeffs.index = coeffs['index']
            coeffs.drop(['index'], axis = 1,inplace = True)
            # Get list off years with fixed effects
            year_list = coeffs['year'].unique().tolist()
            for year in year_list:
                # Create new column names
                old_coeff_name = "fe_{}".format(str(product))
                new_coeff_name = "_".join(['fe',product,year])
                old_pval_name = "pval_{}".format(str(product))
                new_pval_name = "_".join(['pval',product,year])
                # Grab estimates relating to the desired year
                year_subset = coeffs.loc[coeffs['year'] == year,[old_coeff_name, old_pval_name] ].copy()
                year_subset.rename(columns = {old_coeff_name:new_coeff_name,
                                              old_pval_name:new_pval_name}, inplace=True)
                list_of_series.append(year_subset)

                # expand sigma dictionary to new product-years
                if isinstance(sigma, dict):
                    sigma[new_coeff_name] = sigma[product]

        else:
            list_of_series.append(coeffs)

    all_imp_fe = pd.concat(list_of_series, join = 'outer', axis = 1)

    fe_columns = [col for col in all_imp_fe.columns if col.startswith('fe')]
    for col in fe_columns:
        new_col_name = "_".join(['ave', col[3:]])
        if isinstance(sigma, dict):
            sigma_value = sigma[col]
        elif isinstance(sigma, (int, float)):
            sigma_value = sigma
        else:
            raise TypeError('sigma is not a valid type')

        ave = lambda x: math.exp(x / (1 - sigma_value)) - 1
        max_fe = all_imp_fe[col].max()
        all_imp_fe[new_col_name] = all_imp_fe[col] - max_fe
        all_imp_fe[new_col_name] = all_imp_fe[new_col_name].apply(ave)
        all_imp_fe.loc[:,str('sigma_'+col[3:])] = sigma_value

    wide_data = all_imp_fe.copy()
    if format == 'long':
        long_data = all_imp_fe.copy()
        try:
            col_list = [tuple(col.split('_')) for col in all_imp_fe.columns]
            long_data.columns = pd.MultiIndex.from_tuples(col_list)
            long_data = long_data.unstack().reset_index().copy()
            if year_by_year:
                long_data.columns = ['type','sector','year','id','value']
                long_data = long_data.pivot_table(values = 'value',
                                                  index = ['sector','year','id'], columns='type').reset_index()
                long_data['country'] = long_data['id'].str[-3:]

            else:
                long_data.columns = ['type', 'sector', 'id', 'value']
                long_data = long_data.pivot_table(values='value',
                                                  index=['sector',  'id'], columns='type').reset_index()
                long_data['country'] = long_data['id'].str[-7:-4]
            return_data = long_data
        except:
            warn("Could not convert to long, returned wide instead.")
            return_data = wide_data
    else:
        return_data = wide_data

    return return_data

def prep_ave_data_for_ols(ave_data,
                          fe_prefix:str):
    '''
    A function that converts the output from across_country_ave() to a single series that can be used for an OLS
    regression.
    :param ave_data: (DataFrame) A dataframe of AVEs from across_country_ave(). Rows correspond to countries,
    columns to sectors.
    :param fe_prefix: (str) the prefix of the indexes corresponding to the country-AVEs
    :return: (DataFrame) A dataframe in which there is a single column of AVEs, and ID columns of countries associated
    with the AVEs, and the sectors to which they belong.
    '''
    products = list(ave_data.columns.values)
    sigmas = [col for col in products if col.startswith('sigma')]
    [products.remove(sigma) for sigma in sigmas]
    product_frame_list = []
    for code in products:
        product_frame = ave_data[[code]].copy()
        product_frame.rename(columns={code: fe_prefix}, inplace=True)
        product_frame['sector'] = code
        product_frame['country'] = product_frame.index.str.slice(-3)
        product_frame_list.append(product_frame)
    fixed_effect_df = pd.concat(product_frame_list, axis=0)
    return fixed_effect_df


